<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>タイムライン表示</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>



  <style>
    /* スクロール可能なコンテナ */
    .container {
      overflow-x: auto;
      overflow-y: auto;
      width: 100%;
      height: 500px;
      display: block;
    }
    /* ヘッダー */
    .header {
      display: flex;
      justify-content: space-between;
      font-weight: bold;
    }
    /* 各グラフ行 */
.chart-row {
  display: flex; /* 必要に応じて他の子要素に対応 */
  align-items: center; /* 子要素を中央揃え */
  justify-content: center;
  height: 150px; /* 必要な高さを設定 */
  width: 100%; /* 横幅を親要素に合わせる */
  position: relative; /* 必要なら設定 */
  overflow: hidden; /* 描画がはみ出さないように調整 */
}

    /* 出来事行 */
    .event-row {
      display: flex;
      justify-content: space-between;
      background-color: #f0f0f0;
      align-items: center;
      height: 50px;
    }
  </style>
</head>
<body>

  <div class="container">
    <div id="timelineContainer">
      <!-- タイムラインとグラフがここに追加される -->
    </div>
  </div>

  <script>
    // CSVを読み込んでJSONに変換する
    function loadCSV() {
      // Timeline.csvの読み込み
Papa.parse("csv/Timeline.csv", {
  download: true,
  header: true,
  dynamicTyping: true,
  skipEmptyLines: true,
  complete: function(results) {

    
    if (results.errors.length > 0) {
      console.error("Timeline.csvの読み込みエラー:", results.errors);
      results.errors.forEach(error => {
        console.error(`エラー詳細: 行番号 ${error.row}, メッセージ: ${error.message}`);
      });
      return;
    }
    console.log("Timeline.csv読み込み結果:", results.data); // データ確認
    const timelineData = results.data;
    console.log("解析後のタイムラインデータ:", parseTimelineData(timelineData)); // 解析後の確認
    const jsonTimelineData = parseTimelineData(timelineData);

    // 次のCSV読み込み
    Papa.parse("csv/Events.csv", {
      download: true,
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true,
      complete: function(eventResults) {
        if (eventResults.errors.length > 0) {
          console.error("Events.csvの読み込みエラー:", eventResults.errors);
          results.errors.forEach(error => {
            console.error(`エラー詳細: 行番号 ${error.row}, メッセージ: ${error.message}`);
          });
          return;
        }
        console.log("Events.csv読み込み結果:", eventResults.data);
         
        const eventData = eventResults.data;
        const jsonEventData = parseEventData(eventData);

        console.log("タイムラインデータ:", timelineData);
        console.log("イベントデータ:", eventData);
        renderTimeline(jsonTimelineData, jsonEventData);
      }
    });
  }
});

    }


// Timelineデータを解析
function parseTimelineData(timelineData) {
  const timeline = [];
  const regions = new Set();

  timelineData.forEach(item => {
    const period = item.Period || "未定義";
    const region = item.Region || "未定義";
    const state = item.State || "未定義";
    const share = item.Share || 0;
    const color = item.Color || "gray";
    const coordinates = item.Coordinates ? JSON.parse(item.Coordinates) : [];

    regions.add(region);

    // タイムラインに既存の期間があるか確認
    let periodData = timeline.find(p => p.period === period);
    if (!periodData) {
      // 新しい期間を追加
      periodData = { period, states: {} };
      timeline.push(periodData);
    }

    // 現在の期間内で地域データを取得
    let regionData = periodData.states[region] || [];
    const existingStateIndex = regionData.findIndex(s => s.name === state);

    if (existingStateIndex !== -1) {
      // 同じ国名が既に存在する場合、シェアを合算
      regionData[existingStateIndex].share += share;
    } else {
      // 新しい国名を追加
      regionData.push({ name: state, share, color, coordinates });
    }

    periodData.states[region] = regionData;
  });

  // 同じ期間内で同一国名が続く場合をさらに統合
  timeline.forEach(periodData => {
    Object.keys(periodData.states).forEach(region => {
      const states = periodData.states[region];
      periodData.states[region] = states.reduce((acc, curr) => {
        const lastState = acc[acc.length - 1];
        if (lastState && lastState.name === curr.name) {
          // 同じ国名が連続している場合にシェアを統合
          lastState.share += curr.share;
        } else {
          acc.push(curr);
        }
        return acc;
      }, []);
    });
  });

  return { timeline, regions: Array.from(regions) };
}

    
    // Eventsデータを解析
    function parseEventData(eventData) {
      const events = [];
      eventData.forEach(item => {
        const period = item.Period;
        const region = item.Region;
        const state = item.State;
        const title = item.Title;
        const details = item.Details;
        const image = item.Image;
        const coordinates = item.Coordinates.split(",").map(val => parseFloat(val.trim()));
        events.push({ period, region, state, title, details, image, coordinates });
      });
      return events;
    }


    
function renderTimeline(timelineData, eventData) {
  const timelineContainer = document.getElementById("timelineContainer");
  const { timeline, regions } = timelineData;

  // ヘッダー行の作成
  const headerRow = document.createElement("div");
  headerRow.className = "header";
  headerRow.style.display = "flex";

  ["空白", ...regions].forEach(region => {
    const headerCell = document.createElement("div");
    headerCell.textContent = region;
    headerCell.style.flex = "1";
    headerCell.style.textAlign = "center";
    headerCell.style.fontWeight = "bold";
    headerCell.style.borderBottom = "2px solid black";
    headerRow.appendChild(headerCell);
  });
  timelineContainer.appendChild(headerRow);

  // タイムラインデータを順番に処理
  timeline.forEach(item => {
    // 年代に該当するイベントを検索
    
    const matchingEvents = eventData.filter(event => event.period === item.period);
    
    // 積み上げグラフ: 国
    const chartRow = document.createElement("div");
    chartRow.className = "chart-row";
    const chartCell = document.createElement("canvas");
    chartCell.style.height = "200px"; // グラフの高さを調整
    chartRow.appendChild(chartCell);
Chart.register(ChartDataLabels);
    // Chart.js グラフ作成 (年代ごとの国の積み上げグラフ)
    new Chart(chartCell, {
      type: 'bar',
      data: {
        labels: [item.period], // 年代をY軸ラベルに表示
        datasets: Object.keys(item.states).flatMap(region =>
          item.states[region].map(state => ({
            label: state.name, // 王国名
            data: [state.share], // シェア
            backgroundColor: state.color, // 色
            borderColor: 'black',
            borderWidth: 1
          }))
        )
      },
      options: {
        indexAxis: 'y', // 横棒グラフ
        plugins: {
          legend: { display: false }, // 凡例を非表示
          tooltip: { enabled: false }, // ツールチップを非表示
          
          datalabels: {
            color: 'white', // テキスト色
            align: 'center',
            anchor: 'center',
            formatter: (value, context) => context.dataset.label, // 国家名を表示
          },
        },
        responsive: true,
        maintainAspectRatio: false, // サイズを柔軟に調整
        scales: {
          x: {
            display: false,
            stacked: true // 積み上げ
          },
          y: {
            display: true, // 年代を表示
            stacked: true // 積み上げ
          }
        }
      }
    });

    timelineContainer.appendChild(chartRow);

    // 出来事グラフ: 出来事
     if (matchingEvents.length > 0) {
    const eventRow = document.createElement("div");
    eventRow.className = "chart-row";
    const eventCell = document.createElement("canvas");
    eventCell.style.height = "200px"; // グラフの高さを調整
    eventRow.appendChild(eventCell);

    const eventDataset = matchingEvents.map(event => ({
      label: event.title, // 出来事タイトル
      data: [1], // 比率（全て1で固定）
      backgroundColor: 'lightblue', // 出来事の背景色
      borderColor: 'black',
      borderWidth: 1
    }));

    new Chart(eventCell, {
      type: 'bar',
      data: {
        labels: [item.period],
        datasets: eventDataset
      },
      options: {
        indexAxis: 'y',
        plugins: {
          legend: { display: false },
          tooltip: { enabled: false },
        datalabels: {
          color: 'black', // テキストの色
          anchor: 'center', // ラベルの位置
          align: 'center', // ラベルを中央揃え
          formatter: (value, context) => context.dataset.label // 出来事タイトルを表示
        }
        },
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            display: false,
            stacked: true
          },
          y: {
            display: true, // 年代を表示
            stacked: true
          }
        }
      }
    });

    timelineContainer.appendChild(eventRow);
  }
});
}





    // ページ読み込み時にCSVをロード
    window.onload = loadCSV;
  </script>

</body>
</html>

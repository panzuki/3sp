<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ‘ãƒ³ç”Ÿåœ°ã®ç‰©è³ªå¤‰é·ãƒ•ãƒ­ãƒ¼å›³016</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f4f8;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            margin-bottom: 20px;
        }
        svg {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            overflow: visible;
        }
        .link {
            fill: none;
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
            transition: stroke-opacity 0.3s, stroke-width 0.3s;
        }
        .node-group {
            transition: transform 0.3s ease;
        }
        .node {
            cursor: pointer;
        }
        .node-click-area {
            fill: transparent;
            pointer-events: all;
        }
        .node-circle {
            stroke: #fff;
            stroke-width: 2px;
            transition: r 0.2s ease-in-out, fill 0.2s ease-in-out, opacity 0.3s;
        }
        /* é€šå¸¸ã®ãƒãƒ¼ãƒ‰ãƒ›ãƒãƒ¼ */
        .node:hover .node-circle {
            fill: #3b82f6;
            r: 8px;
        }
        /* æ¶ˆæ»…ãƒãƒ¼ãƒ‰ã®ãƒ›ãƒãƒ¼ */
        .extinct-node:hover .extinct-x {
            font-size: 14px; /* ãƒ›ãƒãƒ¼ã§å°‘ã—å¤§ãã */
        }

        .node-label {
            font-size: 8px;
            pointer-events: none;
            user-select: none;
            transition: fill 0.3s;
        }
        .group-label {
            font-size: 18px;
            font-weight: bold;
            text-anchor: middle;
            fill: #555;
        }
        .chart-node-label {
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
            opacity: 1 !important;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            padding: 8px;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .faded {
            opacity: 0.2 !important;
        }
        .highlight-node .node-circle {
            stroke: #333;
            opacity: 1 !important;
        }
        .highlight-node .node-label {
            fill: #000;
            font-weight: bold;
            opacity: 1 !important;
        }
        .highlight-link {
            stroke-opacity: 1 !important;
            stroke-width: 2.5px !important;
        }
        /* ç”Ÿæˆ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è‰²ã¯gold) */
        .highlight-link.generated {
            stroke: gold !important; 
        }
        /* æ¶ˆè²» (æ°´è‰²) */
        .highlight-link.consumed {
            stroke: #00BFFF !important; 
        }
        /* ç›´æ¥ç§»å‹• (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è‰²ã¯#333) */
        .highlight-link.direct {
            stroke: #333 !important; 
        }
        /* æ¶ˆæ»… (ç´«è‰²) */
        .highlight-link.extinct-link {
            stroke: #9400D3 !important; 
            stroke-dasharray: none; 
        }
        
        .extinct-link {
            stroke-dasharray: 4, 2;
        }
        
        .extinct-x {
            font-family: sans-serif;
            font-size: 12px;
            font-weight: bold;
            fill: red;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            user-select: none;
            transition: font-size 0.2s;
        }

    </style>
</head>
<body>
    <h1>ãƒ‘ãƒ³ç”Ÿåœ°ã®ç‰©è³ªå¤‰é·ãƒ•ãƒ­ãƒ¼å›³016</h1>
    <svg id="chart"></svg>
    <div class="tooltip"></div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
          //src="chart.js">
        const width = 1200;
const groupSpacingY = 350;
const charSpacing = 8;
const circleRadius = 8;

const svg = d3.select("#chart");
const chartGroup = svg.append("g");
const tooltip = d3.select("body").select(".tooltip");

const groupLabels = {
    'chart1': 'åŸææ–™',
    'chart2': 'ãƒŸã‚­ã‚·ãƒ³ã‚° (åå¿œ)',
    'chart3': 'ãƒŸã‚­ã‚·ãƒ³ã‚°å¾Œ (ç‰©è³ª)',
    'chart4': 'ç™ºé…µ (åå¿œ)',
    'chart5': 'ç™ºé…µå¾Œ (ç‰©è³ª)',
    // å¿…è¦ã«å¿œã˜ã¦ã€chart6 ä»¥é™ã‚’è¿½åŠ ã—ã¦ãã ã•ã„
};
const groupColors = {
    'chart1': '#a8e6cf', 
    'chart2': '#ff8b94', 
    'chart3': '#dcedc1', 
    'chart4': '#b59fff', 
    'chart5': '#ffe3b5', 
    // å¿…è¦ã«å¿œã˜ã¦ã€chart6 ä»¥é™ã®è‰²ã‚’è¿½åŠ ã—ã¦ãã ã•ã„
};

const fileNames = Object.keys(groupLabels).map(key => `csv/${key}.csv`);
// åå¿œã‚°ãƒ«ãƒ¼ãƒ—ï¼ˆå¶æ•°ç•ªå·ï¼‰ã‚’æŒ‡å®š
const processGroups = new Set(['chart2', 'chart4', 'chart6', 'chart8', 'chart10']);

Promise.all(fileNames.map(url => d3.csv(url).catch(() => null))).then(datasets => {
    const validDatasets = datasets.filter(d => d !== null);
    if (validDatasets.length === 0) {
        console.error("CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚");
        return;
    }

    const nodes = [];
    const links = [];
    const nodeMap = new Map();
    const allData = validDatasets.flat();
    
    // ãƒãƒ¼ãƒ‰ã®ç”Ÿæˆã¨ãƒ‡ãƒ¼ã‚¿ãƒãƒƒãƒ—ã®æ§‹ç¯‰
    allData.forEach(d => {
        if (!d.ç•ªå·) return;
        const groupIndex = validDatasets.findIndex(dataset => dataset.includes(d)) + 1;
        const groupName = `chart${groupIndex}`;
        
        const isProcess = processGroups.has(groupName);

        // IDã¯ã‚°ãƒ«ãƒ¼ãƒ—åã¨å…ƒã®ç•ªå·ã®ã¿ã§ç”Ÿæˆ (å…ƒã®è¡¨ã®ç•ªå·ãŒãƒ¦ãƒ‹ãƒ¼ã‚¯ã§ã‚ã‚‹ã“ã¨ã‚’å‰æã¨ã™ã‚‹)
        const id = `${groupName}-${d.ç•ªå·}`;

        const name = d['ç‰©è³ªå'] || d['åå¿œå'] || d['æ§‹æˆç‰©è³ªå'] || d.ç•ªå·;
        if (!name) return;
        
        // æ¶ˆæ»…ãƒãƒ¼ãƒ‰ã®åˆ¤å®šï¼ˆç‰©è³ªã‚°ãƒ«ãƒ¼ãƒ—ã§ã€å¼•ãç¶™ãç•ªå·ã«è‡ªåˆ†ã®ç•ªå·ãŒã€ŒÃ—ã€ä»˜ãã§å«ã¾ã‚Œã¦ã„ãŸã‚‰æ¶ˆæ»…ï¼‰
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒæ¬¡ã®ç‰©è³ªã‚°ãƒ«ãƒ¼ãƒ—ã§ã‚ã‚‹å ´åˆã®ã€ŒÃ—ã€ã‚’ãƒã‚§ãƒƒã‚¯
        const isExtinct = (groupIndex % 2 === 1 && groupIndex > 1) 
                          ? (d.ç•ªå· && allData.some(item => 
                                item.å¼•ãç¶™ãç•ªå· && 
                                // Chart IndexãŒè‡ªåˆ†ã‚ˆã‚Š2ã¤å¤§ãã„ã‚°ãƒ«ãƒ¼ãƒ—ï¼ˆæ¬¡ã®ç‰©è³ªã‚°ãƒ«ãƒ¼ãƒ—ï¼‰ã®ãƒ‡ãƒ¼ã‚¿è¡Œã‚’ãƒã‚§ãƒƒã‚¯
                                validDatasets.findIndex(dataset => dataset.includes(item)) + 1 === groupIndex + 2 &&
                                item.å¼•ãç¶™ãç•ªå·.includes(`Ã—${d.ç•ªå·}`)
                            ))
                          : false;

        const node = { id, name, group: groupName, number: d.ç•ªå·, isProcess, isExtinct, data: d };
        nodes.push(node);
        nodeMap.set(id, node);
    });
    
    // ãƒªãƒ³ã‚¯ã®ç”Ÿæˆ
    allData.forEach(d => {
        const originalNumber = d.ç•ªå·;
        if (!originalNumber || !d.å¼•ãç¶™ãç•ªå·) return;
        const groupIndex = validDatasets.findIndex(dataset => dataset.includes(d)) + 1;
        const groupName = `chart${groupIndex}`;
        
        const currentNodeId = `${groupName}-${originalNumber}`;
        const currentNode = nodeMap.get(currentNodeId);
        if (!currentNode) return;
        
        const cleanText = d.å¼•ãç¶™ãç•ªå·.replace(/^"|"$/g, '');
        
        // ãƒªãƒ³ã‚¯ãƒ†ã‚­ã‚¹ãƒˆã‚’ç¬¦å·(+,-,Ã—)ã®ç›´å‰ã§åˆ†å‰²ã™ã‚‹æ­£è¦è¡¨ç¾
        const parts = cleanText.split(/,(?=[+-]?\d+[a-z]?|[+-]?[MR]\d+[a-z]?)|(?=Ã—\d+[a-z]?)|(?=Ã—[MR]\d+[a-z]?)/g)
            .map(p => p.trim())
            .filter(p => p && p !== ',');

        parts.forEach(part => {
            let actualPart = part;
            let isExtinct = false;
            let linkType = 'generated'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç”Ÿæˆ

            // ç¬¦å·ã¨Ã—ã®æ¤œå‡º
            if (part.startsWith('Ã—')) {
                isExtinct = true;
                actualPart = part.substring(1);
                linkType = 'extinct-link'; // æ¶ˆæ»…ãƒªãƒ³ã‚¯å°‚ç”¨ã®ã‚¿ã‚¤ãƒ—
            } else if (part.startsWith('-')) {
                actualPart = part.substring(1);
                linkType = 'consumed'; // æ¶ˆè²»
            } else if (part.startsWith('+')) {
                actualPart = part.substring(1);
                linkType = 'generated'; // ç”Ÿæˆ
            }
            
            const reactionMatch = actualPart.match(/([MR]\d+[a-z]?)(?:\((.*?)\))?/);

            if (reactionMatch) {
                // 1. Reaction Link: Rã¾ãŸã¯Mã‚’ä»‹ã—ãŸãƒªãƒ³ã‚¯
                const reactionIdNumber = reactionMatch[1]; 
                const sourceMaterials = reactionMatch[2] ? reactionMatch[2].split(',').map(s => s.trim()).filter(s => s) : [];
                
                const reactionGroupName = `chart${groupIndex - 1}`;
                const reactionNodeId = `${reactionGroupName}-${reactionIdNumber}`;
                const reactionNode = nodeMap.get(reactionNodeId);
                
                if (reactionNode) {
                    // Reaction to Product
                    links.push({ source: reactionNode.id, target: currentNode.id, type: linkType, isExtinct });
                    
                    // Reactants to Reaction
                    sourceMaterials.forEach(matId => {
                        // åå¿œç‰©ãƒãƒ¼ãƒ‰ã¯ Reaction ãƒãƒ¼ãƒ‰ã®ã•ã‚‰ã«ä¸€ã¤å‰ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚ã‚‹
                        const sourceGroupName = `chart${groupIndex - 2}`;
                        const sourceNodeId = `${sourceGroupName}-${matId}`;
                        const sourceNode = nodeMap.get(sourceNodeId);
                        
                        if (sourceNode) {
                            // åå¿œç‰©ã‹ã‚‰åå¿œã¸ã®ãƒªãƒ³ã‚¯ã¯å¸¸ã« 'consumed' ã¾ãŸã¯ 'extinct'
                            const type = sourceNode.isExtinct ? 'extinct-link' : 'consumed';
                            links.push({ 
                                source: sourceNode.id, 
                                target: reactionNode.id, 
                                type: type, 
                                isExtinct: sourceNode.isExtinct 
                            });
                        }
                    });
                }
            } else if (actualPart.match(/^(\d+[a-z]?)$/)) {
                // 2. Direct Link: åå¿œã‚’é€šã•ãªã„ç‰©è³ªé–“ç§»å‹• (Chart1 -> Chart3, Chart3 -> Chart5 ã®ã‚ˆã†ãªãƒªãƒ³ã‚¯)
                const sourceNumber = actualPart;

                // ä¿®æ­£ãƒ­ã‚¸ãƒƒã‚¯: ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒãƒ¼ãƒ‰ãŒç‰©è³ªã‚°ãƒ«ãƒ¼ãƒ— (å¥‡æ•°ã‚°ãƒ«ãƒ¼ãƒ—) ã§ã‚ã‚Šã€
                // ã‹ã¤ã€ã‚½ãƒ¼ã‚¹ãŒå‰ã®ç‰©è³ªã‚°ãƒ«ãƒ¼ãƒ— (groupIndex - 2) ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã€‚
                const prevMaterialGroupIndex = groupIndex - 2;
                
                let sourceNode = null;
                if (groupIndex % 2 === 1 && prevMaterialGroupIndex >= 1) {
                    const sourceGroupName = `chart${prevMaterialGroupIndex}`;
                    const potentialId = `${sourceGroupName}-${sourceNumber}`;
                    sourceNode = nodeMap.get(potentialId);
                }
                
                if (sourceNode) {
                    // ç‰©è³ªé–“ç§»å‹•ã¯ 'direct'ã¨ã—ã€æ¶ˆè²»(-)ã¾ãŸã¯æ¶ˆæ»…(Ã—)ã®å ´åˆã¯ãã‚Œãã‚Œ 'consumed', 'extinct-link' ã‚’å„ªå…ˆã€‚
                    if (linkType === 'generated') linkType = 'direct'; 
                    
                    links.push({ source: sourceNode.id, target: currentNode.id, type: linkType, isExtinct });
                }
            }
        });
    });
    
    // ãƒªãƒ³ã‚¯ã®é‡è¤‡æ’é™¤
    const uniqueLinks = new Map();
    links.forEach(link => {
        const key = `${link.source}-${link.target}-${link.type}-${link.isExtinct}`;
        if (!uniqueLinks.has(key)) {
            uniqueLinks.set(key, link);
        }
    });
    const finalLinks = Array.from(uniqueLinks.values());
    
    const groupData = d3.groups(nodes, d => d.group);

    if (groupData.length === 0) {
        console.error("æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚°ãƒ«ãƒ¼ãƒ—ãŒç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚");
        return;
    }

    // SVGã‚µã‚¤ã‚ºã¨ã‚°ãƒ«ãƒ¼ãƒ—é…ç½®
    const totalHeight = groupData.length * groupSpacingY + 200;
    svg.attr("height", totalHeight).attr("width", width);
    chartGroup.attr("transform", `translate(${width / 2}, 50)`);

    // ãƒãƒ¼ãƒ‰ã®åº§æ¨™è¨ˆç®—
    groupData.forEach(([group, groupNodes], i) => {
        const center = { x: 0, y: i * groupSpacingY };
        if (groupNodes[0] && groupNodes[0].isProcess) {
            // ãƒ—ãƒ­ã‚»ã‚¹ãƒãƒ¼ãƒ‰ï¼ˆé•·æ–¹å½¢é…ç½®ï¼‰
            const nodeSpacing = 15;
            const totalHeight = groupNodes.length * nodeSpacing;
            groupNodes.forEach((node, j) => {
                node.x = center.x;
                node.y = center.y - (totalHeight / 2) + j * nodeSpacing;
            });
        } else {
            // ç‰©è³ªãƒãƒ¼ãƒ‰ï¼ˆå††å½¢é…ç½®ï¼‰
            const radius = 200;
            const textRadius = 140;
            const angleStep = 2 * Math.PI / groupNodes.length;
            
            groupNodes.forEach((node, j) => {
                const angle = j * angleStep;
                
                node.textX = center.x + textRadius * Math.cos(angle);
                node.textY = center.y + textRadius * Math.sin(angle);
                
                const totalTextLength = (node.name ? node.name.length : 0);
                const charWidth = 5; 
                const textHalfLength = totalTextLength * charWidth / 2;
                const pointOffsetFromText = 5 + circleRadius;
                const circleRadiusFromCenter = textRadius + textHalfLength + pointOffsetFromText;
                
                node.circleX = center.x + circleRadiusFromCenter * Math.cos(angle);
                node.circleY = center.y + circleRadiusFromCenter * Math.sin(angle);
                
                node.angle = angle;
            });
        }
    });

    // ãƒªãƒ³ã‚¯ã®æç”»
    const linkElements = chartGroup.append("g")
        .attr("class", "links")
        .selectAll("path")
        .data(finalLinks)
        .enter().append("path")
        .attr("class", d => `link ${d.type} ${d.isExtinct ? 'extinct-link' : ''}`)
        .attr("d", d => {
            const sourceNode = nodeMap.get(d.source);
            const targetNode = nodeMap.get(d.target);
            if (!sourceNode || !targetNode) return;

            let sourceX, sourceY, targetX, targetY;

            // ã‚½ãƒ¼ã‚¹åº§æ¨™ã®æ±ºå®š
            if (sourceNode.isProcess) {
                const textLength = (sourceNode.name ? sourceNode.name.length : 0);
                sourceX = sourceNode.x + (textLength * 5) / 2; 
                sourceY = sourceNode.y;
            } else {
                sourceX = sourceNode.circleX;
                sourceY = sourceNode.circleY;
            }

            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™ã®æ±ºå®š
            if (targetNode.isProcess) {
                const textLength = (targetNode.name ? targetNode.name.length : 0);
                targetX = targetNode.x - (textLength * 5) / 2; 
                targetY = targetNode.y;
            } else {
                targetX = targetNode.circleX;
                targetY = targetNode.circleY;
            }
            
            const dx = targetX - sourceX;
            const dy = targetY - sourceY;

            const isClose = Math.sqrt(dx * dx + dy * dy) < 100;

            if (isClose) {
                // è¿‘ã„å ´åˆã¯ç›´ç·š
                return `M${sourceX},${sourceY} L${targetX},${targetY}`;
            } else {
                // é ã„å ´åˆã¯Så­—ã‚«ãƒ¼ãƒ–
                return `M${sourceX},${sourceY}
                        C${sourceX + dx / 2},${sourceY}
                         ${targetX - dx / 2},${targetY}
                         ${targetX},${targetY}`;
            }
        });

    // ãƒãƒ¼ãƒ‰ã®æç”»
    const nodeElements = chartGroup.selectAll(".node-group")
        .data(groupData)
        .enter().append("g")
        .attr("class", "node-group")
        .selectAll(".node")
        .data(d => d[1])
        .enter().append("g")
        .attr("class", d => `node ${d.isExtinct ? 'extinct-node' : ''}`) 
        .attr("id", d => d.id) 
        .attr("transform", d => d.isProcess ? `translate(${d.x},${d.y})` : null);

    nodeElements.each(function(d) {
        const nodeElement = d3.select(this);
        const nodeName = d.name || d.number;
        if (!nodeName) return;

        if (d.isProcess) {
            // ãƒ—ãƒ­ã‚»ã‚¹ãƒãƒ¼ãƒ‰ï¼ˆé•·æ–¹å½¢ã¨ãƒ†ã‚­ã‚¹ãƒˆï¼‰
            const textLength = nodeName.length;
            nodeElement.append("rect")
                .attr("class", "node-click-area")
                .attr("x", - (textLength * 5) / 2 - 10)
                .attr("y", -10)
                .attr("width", textLength * 5 + 20)
                .attr("height", 20);

            nodeElement.append("text")
                .attr("class", "chart-node-label")
                .attr("x", 0)
                .attr("y", 0)
                .text(nodeName);
        } else {
            // ç‰©è³ªãƒãƒ¼ãƒ‰ï¼ˆå††ã¨ãƒ†ã‚­ã‚¹ãƒˆï¼‰
            nodeElement.append("circle")
                .attr("class", "node-click-area")
                .attr("cx", d => d.circleX)
                .attr("cy", d => d.circleY)
                .attr("r", 20);

            if (d.isExtinct) {
                // æ¶ˆæ»…ãƒãƒ¼ãƒ‰
                nodeElement.append("text")
                    .attr("class", "extinct-x")
                    .attr("x", d => d.circleX)
                    .attr("y", d => d.circleY)
                    .text("Ã—");
            } else {
                // é€šå¸¸ãƒãƒ¼ãƒ‰
                nodeElement.append("circle")
                    .attr("class", "node-circle")
                    .attr("r", circleRadius)
                    .attr("fill", d => groupColors[d.group])
                    .attr("cx", d => d.circleX)
                    .attr("cy", d => d.circleY);
            }
            
            // ãƒãƒ¼ãƒ‰ãƒ©ãƒ™ãƒ« (ç¸¦æ›¸ãé¢¨)
            const nodeText = nodeName;
            const angle = d.angle;
            const textElement = nodeElement.append("text")
                .attr("class", "node-label")
                .attr("text-anchor", "middle")
                .attr("transform", `translate(${d.textX}, ${d.textY}) rotate(${angle * 180 / Math.PI + 90})`);
                
            const totalHeight = (nodeText.length > 0 ? nodeText.length - 1 : 0) * charSpacing;
            const startY = -totalHeight / 2;

            for (let i = 0; i < nodeText.length; i++) {
                textElement.append("tspan")
                    .attr("x", 0)
                    .attr("y", startY + i * charSpacing)
                    .text(nodeText[i]);
            }
        }
    });

    // ã‚°ãƒ«ãƒ¼ãƒ—ãƒ©ãƒ™ãƒ«ã®æç”»
    chartGroup.selectAll(".group-label")
        .data(groupData)
        .enter().append("text")
        .attr("class", "group-label")
        .attr("x", 0)
        .attr("y", d => d[1].length > 0 ? d[1][0].y - 150 : 0) 
        .text(d => groupLabels[d[0]]);

    // ğŸ’¡ ãƒã‚¤ãƒ©ã‚¤ãƒˆã¨ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†
    d3.selectAll(".node")
        .on("mouseover", (event, d) => {
            tooltip.style("opacity", 1)
                .html(`<strong>${d.name}</strong><br>ç•ªå·: ${d.number}${d.isExtinct ? '<br>***æ¶ˆæ»…***' : ''}<br><span style="font-size: 8px;">ID: ${d.id}</span>`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 20) + "px");
        })
        .on("mouseout", () => {
            tooltip.style("opacity", 0);
        })
        .on("click", (event, d) => {
            const isAlreadyHighlighted = d3.select(event.currentTarget).classed("highlight-node");

            // å…¨ã¦ã®ãƒªã‚»ãƒƒãƒˆ
            d3.selectAll(".node").classed("faded", false).classed("highlight-node", false);
            d3.selectAll(".link").classed("faded", false).classed("highlight-link", false).classed("generated", false).classed("consumed", false).classed("direct", false).classed("extinct-link", false);

            if (!isAlreadyHighlighted) {
                const relatedNodeIds = new Set();
                const relatedLinkIds = new Set();
                
                relatedNodeIds.add(d.id);
                
                // å†å¸°çš„ã«ãƒ‘ã‚¹ã‚’æ¢ç´¢ã™ã‚‹é–¢æ•°
                const findPath = (nodeId, direction, isInitialCall = true) => {
                    // isInitialCallã§ãªã„å ´åˆã€é–¢é€£ãƒãƒ¼ãƒ‰ã‚’é‡è¤‡ã—ã¦å‡¦ç†ã—ãªã„ã‚ˆã†ã«ãƒã‚§ãƒƒã‚¯
                    if (relatedNodeIds.has(nodeId) && !isInitialCall) {
                        return;
                    }
                    relatedNodeIds.add(nodeId);

                    if (direction === 'forward') {
                        finalLinks.filter(link => link.source === nodeId).forEach(link => {
                            const linkKey = `${link.source}-${link.target}-${link.type}-${link.isExtinct}`;
                            relatedLinkIds.add(linkKey);
                            findPath(link.target, 'forward', false);
                        });
                    } else if (direction === 'backward') {
                        finalLinks.filter(link => link.target === nodeId).forEach(link => {
                            const linkKey = `${link.source}-${link.target}-${link.type}-${link.isExtinct}`;
                            relatedLinkIds.add(linkKey);
                            findPath(link.source, 'backward', false);
                        });
                    }
                };
                
                if (d.isProcess) {
                    // åå¿œãƒãƒ¼ãƒ‰ã®å ´åˆã€ã‚¤ãƒ³ãƒ—ãƒƒãƒˆã¨ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆã®ã¿ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    finalLinks.forEach(link => {
                        if (link.source === d.id || link.target === d.id) {
                            const linkKey = `${link.source}-${link.target}-${link.type}-${link.isExtinct}`;
                            relatedLinkIds.add(linkKey);
                            relatedNodeIds.add(link.source);
                            relatedNodeIds.add(link.target);
                        }
                    });
                } else {
                    // ç‰©è³ªãƒãƒ¼ãƒ‰ã®å ´åˆã€é †æ–¹å‘/é€†æ–¹å‘ã®ãƒ‘ã‚¹ã‚’ãŸã©ã‚‹
                    const chartNum = parseInt(d.group.replace('chart', ''));
                    const totalGroups = Object.keys(groupLabels).length;
                    
                    if (chartNum === 1) {
                        // Chart1 (åŸææ–™) ã‹ã‚‰ã¯é †æ–¹å‘ã®ã¿
                        findPath(d.id, 'forward');
                    } else if (chartNum === totalGroups && chartNum % 2 === 1) {
                        // æœ€å¾Œã®ç‰©è³ªã‚°ãƒ«ãƒ¼ãƒ—ã‹ã‚‰ã¯é€†æ–¹å‘ã®ã¿
                        findPath(d.id, 'backward');
                    } else if (chartNum % 2 === 1) {
                        // ä¸­é–“ç‰©è³ªï¼ˆChart3, Chart5ãªã©ï¼‰ã‹ã‚‰ã¯ä¸¡æ–¹å‘ã‚’ãŸã©ã‚‹
                        findPath(d.id, 'forward');
                        findPath(d.id, 'backward');
                    }
                }

                // ãƒãƒ¼ãƒ‰ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ/ãƒ•ã‚§ãƒ¼ãƒ‰
                d3.selectAll(".node").classed("faded", node => !relatedNodeIds.has(node.id));
                d3.select(event.currentTarget).classed("highlight-node", true);
                d3.selectAll(".node").filter(node => relatedNodeIds.has(node.id) && node.id !== d.id).classed("highlight-node", true);
                
                // ãƒªãƒ³ã‚¯ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ/ãƒ•ã‚§ãƒ¼ãƒ‰ã¨è‰²ã®æ±ºå®š
                linkElements.classed("faded", link => !relatedLinkIds.has(`${link.source}-${link.target}-${link.type}-${link.isExtinct}`));
                
                linkElements.filter(link => relatedLinkIds.has(`${link.source}-${link.target}-${link.type}-${link.isExtinct}`))
                    .classed("highlight-link", true)
                    .classed("generated", link => link.type === "generated")
                    .classed("consumed", link => link.type === "consumed")
                    .classed("direct", link => link.type === "direct")
                    .classed("extinct-link", link => link.type === "extinct-link"); 
            }
        });
    
    // SVGå¤–ã®ã‚¯ãƒªãƒƒã‚¯ã§ãƒªã‚»ãƒƒãƒˆ
    d3.select("body").on("click", function(event) {
        if (!event.target.closest(".node")) {
            d3.selectAll(".node").classed("faded", false).classed("highlight-node", false);
            d3.selectAll(".link").classed("faded", false).classed("highlight-link", false).classed("generated", false).classed("consumed", false).classed("direct", false).classed("extinct-link", false);
        }
    });

}).catch(error => {
    console.error("D3.jsã®å‡¦ç†ä¸­ã«äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", error);
});
        
    </script>
    
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>パン生地の物質変遷フロー図</title>
    <style>
        body { font-family: 'Helvetica Neue', Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f4f8; color: #333; display: flex; flex-direction: column; align-items: center; }
        svg { background-color: white; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); margin-top: 20px; overflow: visible; }
        .link { fill: none; stroke: #999; stroke-opacity: 0.6; stroke-width: 1.5px; }
        .node { cursor: pointer; }
        .node-circle { stroke: #fff; stroke-width: 2px; }
        .node-rect { fill: #ddd; stroke: #fff; stroke-width: 2px; }
        .node-label, .chart-node-label { font-size: 8px; pointer-events: none; user-select: none; }
        .group-label { font-size: 18px; font-weight: bold; text-anchor: middle; fill: #555; }
        .chart-node-label { font-size: 10px; text-anchor: middle; }
        .tooltip { position: absolute; background-color: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; padding: 8px; border-radius: 4px; pointer-events: none; opacity: 0; transition: opacity 0.2s; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        .faded { opacity: 0.2; }
        .highlight-node .node-circle, .highlight-node .node-rect { fill: #ff6347 !important; }
        .highlight-node .node-circle { r: 10px !important; }
        .highlight-link { stroke-opacity: 1 !important; stroke-width: 2.5px !important; }
        .highlight-link.generated { stroke: #ffc107 !important; }
        .highlight-link.consumed { stroke: #00bcd4 !important; }
        .highlight-link.direct { stroke: #666 !important; }
    </style>
</head>
<body>
    <h1>パン生地の物質変遷フロー図</h1>
    <svg id="chart"></svg>
    <div class="tooltip"></div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const width = 1200;
        const groupSpacingY = 350;
        const circleRadius = 8;
        const groupLabels = { 'chart1': '原材料', 'chart2': 'ミキシング', 'chart3': 'ミキシング後' };
        const groupColors = { 'chart1': '#a8e6cf', 'chart2': '#ff8b94', 'chart3': '#dcedc1' };
        const fileNames = Object.keys(groupLabels).map(key => `csv/${key}.csv`);

        const svg = d3.select("#chart");
        const chartGroup = svg.append("g");
        const tooltip = d3.select(".tooltip");

        Promise.all(fileNames.map(url => d3.csv(url).catch(() => null)))
            .then(datasets => {
                const validDatasets = datasets.filter(d => d !== null && d.length > 0);
                if (validDatasets.length === 0) return console.error("有効なCSVファイルがありません。");

                const nodes = [];
                const links = [];
                const nodeMap = new Map();

                validDatasets.forEach((data, i) => {
                    const groupName = `chart${i + 1}`;
                    const isProcess = (i + 1) % 2 === 0;
                    data.forEach(d => {
                        const name = d['構成物質名'] || d['物質名'] || d['反応名'];
                        if (!d.番号 || !name) return;
                        const id = `${groupName}-${d.番号}`;
                        const node = { id, name, group: groupName, number: d.番号, isProcess, data: d };
                        nodes.push(node);
                        nodeMap.set(d.番号, node);
                    });
                });

                validDatasets.forEach(data => {
                    data.forEach(d => {
                        const currentNode = nodeMap.get(d.番号);
                        if (!currentNode || !d.引き継ぎ番号) return;
                        const parts = d.引き継ぎ番号.replace(/^"|"$/g, '').match(/([+\-]?)([MR]\d+[a-z]?)(?:\((.*?)\))?|([^\s,]+)/g);
                        if (!parts) return;

                        parts.forEach(part => {
                            const reactionMatch = part.match(/([+\-]?)([MR]\d+[a-z]?)(?:\((.*?)\))?/);
                            if (reactionMatch) {
                                const reactionNode = nodeMap.get(reactionMatch[2]);
                                if (!reactionNode) return;
                                const sourceMaterials = reactionMatch[3] ? reactionMatch[3].split(',').map(s => s.trim()) : [];
                                sourceMaterials.forEach(matId => {
                                    const sourceNode = nodeMap.get(matId);
                                    if (sourceNode) links.push({ source: sourceNode.id, target: reactionNode.id, type: 'consumed' });
                                });
                                if (reactionMatch[1] !== '-') links.push({ source: reactionNode.id, target: currentNode.id, type: 'generated' });
                            } else {
                                const sourceNode = nodeMap.get(part.trim());
                                if (sourceNode) links.push({ source: sourceNode.id, target: currentNode.id, type: 'direct' });
                            }
                        });
                    });
                });

                const finalLinks = Array.from(new Map(links.map(link => [`${link.source}-${link.target}-${link.type}`, link])).values());
                const groupData = d3.groups(nodes, d => d.group);

                const totalHeight = groupData.length * groupSpacingY + 200;
                svg.attr("height", totalHeight).attr("width", width);
                chartGroup.attr("transform", `translate(${width / 2}, 50)`);

                groupData.forEach(([group, groupNodes], i) => {
                    const center = { x: 0, y: i * groupSpacingY };
                    if (groupNodes[0] && groupNodes[0].isProcess) {
                        const nodeSpacing = 15;
                        const totalHeight = groupNodes.length * nodeSpacing;
                        groupNodes.forEach((node, j) => {
                            node.x = center.x;
                            node.y = center.y - (totalHeight / 2) + j * nodeSpacing;
                        });
                    } else {
                        const radius = 150;
                        const angleStep = 2 * Math.PI / groupNodes.length;
                        groupNodes.forEach((node, j) => {
                            const angle = j * angleStep;
                            node.circleX = center.x + radius * Math.cos(angle);
                            node.circleY = center.y + radius * Math.sin(angle);
                            node.textX = center.x + (radius + 20) * Math.cos(angle);
                            node.textY = center.y + (radius + 20) * Math.sin(angle);
                            node.angle = angle;
                        });
                    }
                });

                const linkElements = chartGroup.append("g").attr("class", "links")
                    .selectAll("path").data(finalLinks).enter().append("path")
                    .attr("class", d => `link ${d.type}`)
                    .attr("d", d => {
                        const source = nodes.find(n => n.id === d.source);
                        const target = nodes.find(n => n.id === d.target);
                        if (!source || !target) return;
                        const sourceX = source.isProcess ? source.x + (source.name.length * 5) / 2 : source.circleX;
                        const sourceY = source.isProcess ? source.y : source.circleY;
                        const targetX = target.isProcess ? target.x - (target.name.length * 5) / 2 : target.circleX;
                        const targetY = target.isProcess ? target.y : target.circleY;
                        const dx = targetX - sourceX;
                        const dy = targetY - sourceY;
                        return `M${sourceX},${sourceY}C${sourceX + dx / 2},${sourceY} ${targetX - dx / 2},${targetY} ${targetX},${targetY}`;
                    });

                const nodeGroups = chartGroup.selectAll(".node-group").data(groupData).enter().append("g").attr("class", "node-group");
                nodeGroups.append("text").attr("class", "group-label").attr("x", 0).attr("y", d => d[1][0].y - 150).text(d => groupLabels[d[0]]);

                const nodesElements = nodeGroups.selectAll(".node").data(d => d[1]).enter().append("g").attr("class", "node");

                nodesElements.each(function(d) {
                    const element = d3.select(this);
                    if (d.isProcess) {
                        element.attr("transform", `translate(${d.x},${d.y})`);
                        const rectWidth = d.name.length * 5 + 10;
                        element.append("rect").attr("class", "node-click-area").attr("x", -rectWidth / 2).attr("y", -10).attr("rx", 5).attr("ry", 5).attr("width", rectWidth).attr("height", 20).style("fill", "transparent");
                        element.append("rect").attr("class", "node-rect").attr("x", -rectWidth / 2).attr("y", -10).attr("rx", 5).attr("ry", 5).attr("width", rectWidth).attr("height", 20);
                        element.append("text").attr("class", "chart-node-label").attr("x", 0).attr("y", 0).text(d.name);
                    } else {
                        element.append("circle").attr("class", "node-click-area").attr("cx", d.circleX).attr("cy", d.circleY).attr("r", 20).style("fill", "transparent");
                        element.append("circle").attr("class", "node-circle").attr("r", circleRadius).attr("fill", groupColors[d.group]).attr("cx", d.circleX).attr("cy", d.circleY);
                        const textElement = element.append("text").attr("class", "node-label").attr("text-anchor", "middle").attr("transform", `translate(${d.textX}, ${d.textY})`);
                        const totalHeight = (d.name.length - 1) * 8;
                        const startY = -totalHeight / 2;
                        for (let i = 0; i < d.name.length; i++) {
                            textElement.append("tspan").attr("x", 0).attr("y", startY + i * 8).text(d.name[i]);
                        }
                    }
                });

                d3.selectAll(".node")
                    .on("mouseover", (e, d) => tooltip.style("opacity", 1).html(`<strong>${d.name}</strong><br>番号: ${d.number}`).style("left", `${e.pageX + 10}px`).style("top", `${e.pageY - 20}px`))
                    .on("mouseout", () => tooltip.style("opacity", 0))
                    .on("click", (e, d) => {
                        const isHighlighted = d3.select(e.currentTarget).classed("highlight-node");
                        d3.selectAll(".node, .link").classed("faded", false).classed("highlight-node", false).classed("highlight-link", false).classed("generated", false).classed("consumed", false).classed("direct", false);
                        if (isHighlighted) return;

                        const relatedNodes = new Set();
                        const nodesToProcess = [d];
                        while (nodesToProcess.length > 0) {
                            const currentNode = nodesToProcess.shift();
                            if (relatedNodes.has(currentNode)) continue;
                            relatedNodes.add(currentNode);
                            finalLinks.forEach(link => {
                                if (link.source === currentNode.id) {
                                    const targetNode = nodes.find(n => n.id === link.target);
                                    if (targetNode) nodesToProcess.push(targetNode);
                                } else if (link.target === currentNode.id) {
                                    const sourceNode = nodes.find(n => n.id === link.source);
                                    if (sourceNode) nodesToProcess.push(sourceNode);
                                }
                            });
                        }

                        d3.selectAll(".node").classed("faded", n => !relatedNodes.has(n));
                        d3.selectAll(".link").classed("faded", l => !(relatedNodes.has(nodes.find(n => n.id === l.source)) && relatedNodes.has(nodes.find(n => n.id === l.target))));

                        d3.selectAll(".node").filter(n => relatedNodes.has(n)).classed("highlight-node", true);
                        linkElements.filter(l => !d3.select(l).classed("faded")).classed("highlight-link", true).classed(l => l.type, true);
                    });

                d3.select("#chart").on("click", function(e) {
                    if (!e.target.closest(".node")) {
                        d3.selectAll(".node, .link").classed("faded", false).classed("highlight-node", false).classed("highlight-link", false).classed("generated", false).classed("consumed", false).classed("direct", false);
                    }
                });
            })
            .catch(err => console.error("データ読み込み中にエラーが発生しました:", err));
    </script>
</body>
</html>
